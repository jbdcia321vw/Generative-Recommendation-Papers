import arxiv
import json
import re
import os
from datetime import datetime, timedelta
from typing import List, Dict, Tuple
from zai import ZhipuAiClient

class PaperUpdater:
    def __init__(self, paper_path):
        self.existing_papers = set()
        self.keywords = self.load_keywords()
        self.paper_path = paper_path
        self.client = self.get_paper_classify_agent()
        
        # 定义分类体系
        self.category_hierarchy = {
            "Survey": ["General Survey", "Technical Survey", "Application Survey"],
            "Semantic_ID": ["Text-based Semantic ID", "Multimodal Semantic ID", "Structured Term ID"],
            "Model_Architecture": ["LLM-based", "Diffusion-based", "Hybrid Models"],
            "Training_Technique": ["Reward Models", "Model Merging", "Alignment Techniques"],
            "Application": ["Music Recommendation", "Cross-domain", "Temporal-aware"]
        }

    def load_keywords(self) -> List[str]:
        """加载查询关键词"""
        with open('scripts/keywords.txt', 'r') as f:
            return [line.strip() for line in f if line.strip()]

    def get_paper_classify_agent(self):
        """初始化GLM API客户端"""
        key = os.environ.get("ZHIPUAI_API_KEY")
        if not key:
            print("API key Missing")
            exit(0)
        return ZhipuAiClient(api_key=os.environ.get("ZHIPUAI_API_KEY"))  # 请替换为您的API Key
        

    def classify_paper_with_llm(self, paper_info: Dict) -> Tuple[bool, str, str]:
        """使用GLM API对论文进行分类"""
        system_prompt = """
你是一位专注于推荐系统领域的资深论文分类专家。
 
为了更准确地判断论文是否属于“生成式推荐”领域，请参考以下背景知识：
生成式推荐是一种新兴的推荐范式，它利用生成式AI技术（如大语言模型LLM、扩散模型Diffusion Models等）来直接生成推荐项或用户交互序列，而非仅仅是对现有候选集进行排序。
请特别以2023年Google发布的Tiger模型作为该领域的典型参考案例。Tiger模型展示了如何将生成式任务应用于推荐系统，并提出了使用semantic ID（语义ID）表示item的思想体现了生成式推荐在处理序列推荐和用户兴趣建模方面的独特优势。
如果论文探讨了利用生成模型（尤其是类似Tiger的架构或思路）来生成推荐结果，请将其归类为生成式推荐领域。
"""
        prompt = f"""
请对以下学术论文进行分类。论文信息：
标题：{paper_info['title']}
摘要：{paper_info['summary']}

请判断该论文是否属于生成式推荐系统领域。

请严格按以下格式返回结果：
是否属于生成式推荐：是/否

其中冒号前的内容为固定中文字符串，冒号后的内容为分类结果。不要输出多余信息。因为后续处理流程会使用line.split(';')[1].strip()=='是'来判断是否属于生成式推荐。

"""

        try:
            response = self.client.chat.completions.create(
                model="glm-4.5-air",
                messages=[
                    {"role": "system", "content": system_prompt},  # 添加System消息
                    {"role": "user", "content": prompt}
                ],
                max_tokens=10000,
                temperature=0.3
            )
            
            result = response.choices[0].message.content
            #print("GLM API返回结果:", result)
            return ("是" == result.split('：')[1].strip())
            
        except Exception as e:
            print(f"GLM API调用失败: {e}")
            return False

    def load_existing_papers(self) -> None:
        """加载已有论文信息用于去重"""
        with open(self.paper_path, 'r', encoding='utf-8') as f:
            content = f.read()
        arxiv_pattern = r'arxiv\.org/abs/(\d+\.\d+)'
        self.existing_papers = set(re.findall(arxiv_pattern, content, re.IGNORECASE))

    def query_new_papers(self) -> List[Dict]:
        """查询arXiv最新论文"""
        new_papers = []
        client = arxiv.Client()
        
        for keyword in self.keywords:
            search_query = f'ti:"{keyword}" OR abs:"{keyword}"'
            search = arxiv.Search(
                query=search_query,
                max_results=200,
                sort_by=arxiv.SortCriterion.SubmittedDate,
                sort_order=arxiv.SortOrder.Descending
            )
            
            try:
                for result in client.results(search):
                    # 日期过滤：只看30天内的
                    if result.published.date() < (datetime.now() - timedelta(days=30)).date():
                        continue
                    
                    arxiv_id = result.entry_id.split('/')[-1].replace('v1', '').replace('v2', '')
                    if arxiv_id in self.existing_papers:
                        continue

                    # 构建论文信息字典，补充 journal_ref 和 comment
                    paper_info = {
                        'title': result.title,
                        'authors': [author.name for author in result.authors],
                        'arxiv_id': arxiv_id,
                        'pdf_url': result.pdf_url,
                        'year': result.published.year,
                        'summary': result.summary,
                        'primary_category': str(result.primary_category),
                        'journal_ref': result.journal_ref,  # 新增
                        'comment': result.comment            # 新增
                    }
                    
                    # 使用GLM进行分类
                    is_generative = self.classify_paper_with_llm(paper_info)
                    paper_info['venue'] = str(self.determine_venue(paper_info)).strip()
                    
                    if is_generative:
                        new_papers.append(paper_info)
                        self.existing_papers.add(arxiv_id)

                    
            except Exception as e:
                print(f"查询关键词 '{keyword}' 时出错: {e}")
                continue
                
        return new_papers

    def format_paper_entry(self, paper: Dict) -> str:
        """格式化论文条目"""
        year = paper['year']
        venue = paper['venue']
        
        if len(venue.split(' ')) > 1:
            venue,year = venue.split(' ')
        abs_url = paper['pdf_url'].replace('pdf','abs').replace('v1', '').replace('v2', '')
        
        entry = f"- `{venue}({year})`{paper['title']} **[[PDF]({abs_url})]**\n"
        
        return entry
    def determine_venue(self, paper: Dict) -> str:
        target_venues = [
                "NeurIPS", "ICML", "ICLR", "AAAI", "IJCAI", "TOIS", "NAACL"
                "ACL", "EMNLP", "WSDM", "TMLR", "GenRec", "ICDE"
                "KDD", "WWW", "SIGIR-AP","SIGIR", "TKDE", "TORS", "CIKM", "RecSys",
                "JMLR", "TPAMI", "TIP", "NIPS", "EMNLP"
            ]
        def extract_venue(desc):
            if not desc:
                return 'Arxiv'
            for venue in target_venues:
                if venue.lower() in desc.lower():
                    # 尝试提取年份
                    # 正则逻辑：查找 Venue 名称后的年份
                    year_match = re.search(rf'{venue}.*?((?:19|20)\d{{2}})', desc, re.IGNORECASE)
                    if year_match:
                        return f"{venue} {year_match.group(1)}"
                    # 如果没找到年份，仅返回会议名
                    return venue
            return 'Arxiv'
        """根据论文信息确定会议/期刊"""
        # 1. 检查是否有正式的期刊引用
        if paper.get('journal_ref'):
            venue = extract_venue(paper['journal_ref'].strip())
            if venue != 'Arxiv':
                return venue
        
        # 2. 检查 Comment 字段中的会议信息
        comment = paper.get('comment', '')
        return extract_venue(comment)

    def update_readme(self, new_papers: List[Dict]) -> bool:
        """更新主README.md文件"""
        if not new_papers:
            print("没有发现新论文")
            return False

        # 读取现有README内容
        with open(self.paper_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # 找到Generative Recommendation部分
        pattern = r'(### Generative Recommendation\n)(.*?)(?=\n###|\Z)'
        match = re.search(pattern, content, re.DOTALL)
        
        if not match:
            print("未找到Generative Recommendation部分")
            return False

        # 构建新内容
        new_entries = []
        for paper in new_papers:
            new_entries.append(self.format_paper_entry(paper))

        updated_section = match.group(1) + ''.join(new_entries) + match.group(2)
        new_content = content.replace(match.group(0), updated_section)

        # 写回文件
        with open(self.paper_path, 'w', encoding='utf-8') as f:
            f.write(new_content)

        print(f"成功添加 {len(new_papers)} 篇新论文")
        return True

    def main(self):
        """主执行函数"""
        self.load_existing_papers()
        new_papers = self.query_new_papers()
        
        if self.update_readme(new_papers):
            commit_message = f"Auto-update: Add {len(new_papers)} new papers - {datetime.now().strftime('%Y-%m-%d')}"
            print(commit_message)
        else:
            print("无需更新")

if __name__ == "__main__":
    updater = PaperUpdater(paper_path='README.md')
    updater.main()
